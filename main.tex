\documentclass[10pt,a4paper]{article}

\input{AEDmacros}
\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex
\usepackage{titlesec}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\titulo{Trabajo práctico 1}
\subtitulo{Especificación y WP}

\fecha{\today}

\materia{Algoritmos y Estructura de Datos}
\grupo{SinGrupo4}

\integrante{Algañaraz, Franco}{001/01}{francoarga10@gmail.com}
\integrante{Illescas, Marcos}{390/14}{marcosillescas90@gmail.com}
\integrante{Bahamonde, Matias}{694/21}{matubaham@gmail.com}
\integrante {Marión, Ian Pablo}{004/01}{ianfrodin@gmail.com}
% Pongan cuantos integrantes quieran

% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}

\begin{document}

\maketitle

\section{Especifiación}


\subsection{grandesCiudades}

\begin{proc}{grandesCiudades}{\In ciudades: \TLista{Ciudad}}{\TLista{Ciudad}}
	\requiere{True}
	\asegura{\longitud{res} = CantidadCiudadesMayor50000(ciudades) \; \wedge \\
          (\forall i: \ent)(0 \leq i < \longitud{res} \implicaLuego (\exists j: \ent)(0 \leq j < \longitud{ciudades} \yLuego (res[i] = ciudades[j] \wedge ciudades[j].habitantes > 50000)))}
\end{proc}


\aux{CantidadCiudadesMayor50000}{\In s: \TLista{Ciudad}}{\ent} \\ {\sum_{i=0}^{|s|-1} \IfThenElse{s[i].habitantes > 50000}{1}{0};}

\subsection{sumaDeHabitantes}

\begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades: \TLista{Ciudad}, \In mayoresDeCiudades: \TLista{Ciudad}}{\TLista{Ciudad}}
	\requiere{|menoresDeCiudades| = |mayoresDeCiudades| \; \; \wedge \; \; \\
          mismosNombres(menoresDeCiudades, mayoresDeCiudades)} 
	\asegura{|res| = |menoresDeCiudades| \; \wedge \\
          (\forall i: \ent)(0 \leq i < |res| \implicaLuego (\exists j: \ent)(\exists k: \ent)(0 \leq j < k < |menoresDeCiudad| \; \yLuego \\ siCoincidenNombresSumoHabitantes(res, menoresDeCiudades, mayoresDeCiudades, i, j, k))}
\end{proc}

\pred{mismosNombres}{\In s: \TLista{Ciudad}, \In t: \TLista{Ciudad}}{(\forall i: \ent) (0 \leq i < |s| \implicaLuego (\exists j: \ent) (0 \leq j < |t| \yLuego s[i].nombre = t[j].nombre))}

\pred{siCoincidenNombresSumoHabitantes}{\In s: \TLista{Ciudad}, \In t: \TLista{Ciudad}, \In r: \TLista{Ciudad}, \In i: \ent, \In j: \ent, \In k: \ent}{(s[i].nombre = t[j].nombre \; \wedge \;  s[i].nombre = r[k].nombre) \longrightarrow  s[i].habitantes = t[j].habitantes + r[k].habitantes}


\subsection{hayCamino}

\begin{proc}{hayCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde : \ent, \In hasta : \ent}{\bool}
	\requiere{0 \leq desde < |distancias| \land 0 \leq hasta < |distancias|}
	\asegura{res = \True \iff existeCamino(distancia, desde, hasta)}
\end{proc}

\pred{existeCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde : \ent, \In hasta : \ent}{\existe[unalinea]{camino}{\TLista{\ent}}{|camino| \geq 2 \land camino[0] = desde \land camino[|camino| - 1] = hasta \land 
          (\forall i: \ent)(0 \leq i < |camino| - 1 \rightarrow distancias[camino[i]][camino[i+1]] > 0)}}

\subsection{cantidadCaminosNSaltos}

\begin{proc}{cantidadCaminosNSaltos}{\In conexion : \TLista{\TLista{\ent}}, \In n : \ent}{\TLista{\ent}}
	\requiere{n \geq 1 \land conexion = C_0}
	\asegura{conexion = {C_0}^n}
\end{proc}

\subsection{caminoMínimo}

\begin{proc}{caminoMinimo}{\In origen : \nat, \In destino : \ent, \In distancias : \TLista{\TLista{\ent}}}{\TLista{\ent}}
	\requiere{0 \leq origen < |distancias| \land 0 \leq destino < |distancias|}
	\asegura{(res = \lvacia \iff ¬existeCamino(distancias, origen, destino) \lor origen = destino) \land (res \neq \lvacia \implies (\forall camino : \TLista{\ent})(camino[0] = origen \land camino[|camino| - 1] = destino \land sumaDistancias(res, distancias) \leq sumaDistancias(camino, distancias)))}
    \aux{sumaDistancia}{\In camino : \TLista{\ent}, \In distancias : \TLista{\TLista{\ent}}}{\ent}{\sum_{i=0}^{|camino|-2} distancias[camino[i]][camino[i+1]]}
\end{proc}



\section{Demostraciones de correctitud}

\subsection{Demostrar que la implementación es correcta con respecto a la especificación.}


\begin{proc}
{poblacionTotal}{\In ciudades: \TLista{Ciudad}}{\ent}
\requiere{(\exists j: \ent)(0 \leq j < |ciudades| \yLuego ciudades[j].habitantes > 50000) \wedge \\
(\forall k: \ent)(0 \leq k < |ciudades| \implicaLuego ciudades[i].habitantes \geq 0) \wedge \\
(\forall m: \ent)(\forall n: \ent)(0 \leq m < n < |ciudades| \implicaLuego ciudades[m].nombre \neq ciudades[n].nombre)
}
\asegura{res = \sum_{i=0}^{|ciudades|-1} ciudades[i].habitantes}    
\end{proc}


$ \\
res = 0 \\
i = 0 \\
while \; (i < ciudades.length) \; do  \par
     res = res + ciudades.[i].habitantes \par
     i = i + 1 \\
endwhile  \\   $
\\

P \equiv {A \wedge B \wedge C} \par
A \equiv {(\exists j: \ent)(0 \leq j < |ciudades| \yLuego ciudades[j].habitantes > 50000)} \par
B \equiv {(\forall k: \ent)(0 \leq k < |ciudades| \implicaLuego ciudades[i].habitantes \geq 0)} \par
C \equiv {(\forall m: \ent)(\forall n: \ent)(0 \leq m < n < |ciudades| \implicaLuego ciudades[m].nombre \neq ciudades[n].nombre)}
\\ \\
Pc \equiv {res = 0 \; \wedge i = 0 \; \wedge A \wedge B \wedge C} 
\\ \\
B \equiv {i < |ciudades|}
\\ \\
I \equiv{0 \leq i \leq |ciudades| \yLuego res = \sum_{j=0}^{i-1} ciudades[j].habitantes}
\\ \\
Q \equiv{Qc \equiv{res = \sum_{i=0}^{|ciudades|-1} ciudades[i].habitantes}}


\subsubsection{Pc \implies I}
Pc \equiv {res = 0 \; \wedge i = 0 \; \wedge A \wedge B \wedge C} \implies 0 \leq 0  \leq |ciudades| \yLuego 0 = \sum_{j=0}^{-1} ciudades[j].habitantes \equiv \par 
\vspace{5px}
{\centering 0 \leq |ciudades| \yLuego 0 = 0 \\
\vspace{5px}
True \yLuego \; $True$ \\
\vspace{5px}
True \\
\vspace{5px}
 Pc \implies I\par}


\subsection{Demostrar que el valor devuelto es mayor a 50.000.}

\end{document}